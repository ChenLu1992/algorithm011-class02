学习笔记
  哈希表	通过哈希函数把要存储的值映射到一个位置。
	哈希碰撞：多组数据通过哈希函数得到的索引相同。解决方法：拉链式，在哈希索引处使用链表存储这几组数据
	查询、添加、删除 时间复杂度都是O(1)
	应用 缓存：LRU Cache 键值对存储：Redis
	练习：
	有效的字母异位词（亚马逊、Facebook、谷歌在半年内面试中考过）
	字母异位词分组（亚马逊在半年内面试中常考）
	两数之和（亚马逊、字节跳动、谷歌、Facebook、苹果、微软、腾讯在半年内面试中常考）
	
  树
	二叉树：儿子节点只有两个的树
		遍历：前序 根 左 右
			 中序 左 根 右 
			 后序 左 右 根
		对于一个无序的二叉树，查询、删除、创建的时间复杂度是O(n)	 
	二叉搜索树：
		有序的二叉树，是指一颗空树或具有下列性质的树：
			1、左子树上所有节点的值均小于根节点的值
			2、右子树上所有节点的值均大于根节点的值
			3、以此类推，左右子树也分别为二叉搜索树(这就是相似性)
		查询 删除 创建节点的时间复杂度 均为O(logn)
			删除一个节点的时候，一般取这个节点的右子树中最小的节点来进行替换
	
	树和图的差别：图有环，树无环
	链表是特殊的树（只有左或右儿子），树是特殊的图（无环的图）
	

  堆heap
	可以迅速找到一堆数中的最大值或最小值
		大顶堆、大根堆（根节点最大）
		小顶堆、小根堆（根节点最小）
	二叉堆
		常见操作 
			find-max 或 find-min  O(1)
			delete-max 或 delete-min  O(logn)
			insert（create）  O(logn)
		性质
			 通过完全二叉树实现（根和每一级节点都是满的，除了最下面一层叶子可能不满）
			 树中任意节点的值总是>=其子节点的值
			 注意：不是二叉搜索树，因为二叉搜索树查找无法O(1)找到最大值或最小值
		实现
			 一般通过数组来实现，因为是完全二叉树
			 根元素放在索引为0的位置，则父节点和子节点关系如下：
				1、节点索引为i的，左儿子索引为 2*i+1
				2、节点索引为i的，右儿子索引为 2*i+2
				3、节点索引为i的，父节点索引为 floor((i-1)/2) ---- i-1除以2，再取整
			 注意：二叉堆是堆的一种常见且简单的实现，但并不是最优的实现，工程中并不常用。
			 如果工程中需要用到这样的结构，可以直接使用优先队列（priority queue）
		insert 插入操作
			1、新元素一律插入到堆的尾部
			2、依次向上调整整个堆的结构，一直到根（HeapifyUp）
				 与父节点比较，如果大于父节点，则与父节点交换在数组中的位置
		delet max 删除堆顶操作
			1、堆尾元素替换顶部根元素
			2、依次从根部往下调整整个堆的结构  （HeapifyDown）
				替换后的根元素与左右儿子比较，如果根元素小于左右儿子，则与最大的儿子进行交换数组中的位置
	斐波那契堆
		find-max 或 find-min  O(1)
		delete-max 或 delete-min  O(logn)
		insert（create）  O(1)
	严格的斐波那契堆
		find-max 或 find-min  O(1)
		delete-max 或 delete-min  O(logn)
		insert（create）  O(1)
